// ignore_for_file: non_constant_identifier_names, constant_identifier_names
import 'dart:io';
import 'package:archive/archive_io.dart';
import 'package:colorify/backend/io/addon/hash_icon.dart';
import 'package:colorify/backend/io/addon/manifest.dart';
import 'package:colorify/backend/io/addon/script.dart';
import 'package:path/path.dart' as path;
import 'package:colorify/const.dart';
import 'package:flutter/material.dart';
import 'package:vector_math/vector_math.dart';

enum GeneratorType { Particle, Block }

class Archiver {
  late BuildContext context;
  late GeneratorType type;
  late Directory dir;

  late bool arch;
  late bool useStruct;

  late String packageName;
  late String packageDescription;

  late Directory dir_func;
  late Directory dir_script;
  late Directory dir_struct;

  int lastFileIndex = 0;
  Vector3 blockAreaSize = Vector3(0, 0, 0);

  Archiver({
    required this.context,
    required this.type,
    required this.dir,
    required this.arch,
    required this.useStruct,
    required this.packageName,
    required this.packageDescription,
  }) {
    if (packageName.isEmpty) {
      DateTime now = DateTime.now();
      int year = now.year;
      int month = now.month;
      int day = now.day;
      int hour = now.hour;
      int minute = now.minute;
      int ms = now.millisecond;
      packageName = '${year}_${month}_${day}_${hour}_${minute}_$ms';
    }
    if (packageDescription.isEmpty) {
      packageDescription = 'Generated by Colorify';
    }
  }

  Future _showLoading(Future<void> f) {
    return showDialog(
      context: context,
      builder: (BuildContext context) {
        return FutureBuilder(
          future: f,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return Dialog(
                elevation: 0,
                backgroundColor: lightPopupColor.withOpacity(0.9),
                child: Container(
                  width: 100,
                  height: 150,
                  padding: const EdgeInsets.all(22),
                  decoration: BoxDecoration(borderRadius: BorderRadius.circular(8)),
                  child: Column(
                    children: [
                      Row(
                        children: [
                          Text(
                            'Processing',
                            style: TextStyle(
                              fontSize: 20,
                              fontFamily: "PingFang SC",
                              color: lightIconColor,
                            ),
                          ),
                          const SizedBox(
                            width: 10,
                          ),
                          const Icon(Icons.bolt)
                        ],
                      ),
                      const SizedBox(
                        height: 20,
                      ),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          CircularProgressIndicator(
                            color: lightIconColor,
                          )
                        ],
                      ),
                    ],
                  ),
                ),
              );
            } else if (snapshot.hasError) {
              return AlertDialog(
                backgroundColor: lightPopupColor.withOpacity(0.9),
                title: const Row(
                  children: [
                    Text(
                      'Exception',
                      style: TextStyle(
                        fontFamily: "PingFang SC",
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    SizedBox(
                      width: 10,
                    ),
                    Icon(Icons.error_outline),
                  ],
                ),
                content: Text(
                  '${snapshot.error}',
                  style: const TextStyle(
                    fontFamily: "PingFang SC",
                  ),
                ),
              );
            } else {
              return AlertDialog(
                backgroundColor: lightPopupColor.withOpacity(0.9),
                title: const Text(
                  '完成！',
                  style: TextStyle(
                    fontFamily: "PingFang SC",
                    fontWeight: FontWeight.bold,
                  ),
                ),
              );
            }
          },
        );
      },
    );
  }

  Future<void> _deletePackage(Directory directory) async {
    if (directory.existsSync()) {
      directory.delete(recursive: true);
    }

    return;
  }

  Future<void> _createPackage() async {
    Directory dir_top = Directory(path.join(dir.path, 'output'));
    Directory dir_functions = Directory(path.join(dir.path, 'output/functions'));
    Directory dir_scripts = Directory(path.join(dir.path, 'output/scripts'));
    Directory dir_structures = Directory(path.join(dir.path, 'output/structures'));
    Directory dir_struct_namespace = Directory(path.join(dir.path, 'output/structures/colorify'));

    await dir.create(recursive: true);
    await dir_top.create(recursive: true);
    await dir_functions.create(recursive: true);
    await dir_scripts.create(recursive: true);
    await dir_structures.create(recursive: true);
    await dir_struct_namespace.create(recursive: true);

    dir_func = dir_functions;
    dir_script = dir_scripts;
    dir_struct = dir_struct_namespace;
  }

  Future<void> _createManifest(String name, String description) async {
    final manifest = StringBuffer();
    manifest.write(getManifest(name, description));

    final output = File(path.join(dir.path, 'output/manifest.json'));
    await output.writeAsString(manifest.toString());
  }

  Future<void> _createScript() async {
    final script = getScript(
      type: type,
      lastFileIndex: lastFileIndex,
      useStruct: useStruct,
      blockAreaSize: blockAreaSize,
    );
    final savePath = path.join(dir_script.path, 'index.js');
    final file = File(savePath);
    file.writeAsString(script);
  }

  Future<void> _archive() async {
    Directory dir_top = Directory(path.join(dir.path, 'output'));
    await _createManifest(packageName, packageDescription);
    await _createScript();
    await genHashIcon(Directory(path.join(dir.path, 'output/pack_icon.png')), packageName);

    final sourcePath = dir_top;
    final encoder = ZipFileEncoder();
    await encoder.zipDirectoryAsync(sourcePath, filename: path.join(dir.path, 'out.mcpack'));
  }

  Future<void> prep() async {
    await _deletePackage(dir);
    await dir.create();
    if (arch) await _createPackage();
  }

  Future<void> gen(BuildContext context, Future<dynamic> f, bool arch) async {
    final dynamic res = await f;

    if (!useStruct) {
      lastFileIndex = res;
    } else {
      blockAreaSize = res;
    }

    if (arch) {
      await _showLoading(_archive());
    }
  }
}
